<!DOCTYPE HTML>
<html>

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Background Remover - Remove Image Backgrounds</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="Remove backgrounds from images with AI-powered precision" />
	<meta name="keywords" content="background remover, remove background, image editor, ai background removal" />
	<meta name="author" content="Yusuf Morsi" />

	<!-- Favicon -->
	<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='12' fill='%231e3a8a'/%3E%3Cpath d='M20 25 L20 75 L80 75 L80 45 L60 45 L60 25 Z' fill='white'/%3E%3Cpath d='M60 25 L60 45 L80 45 Z' fill='%233b82f6'/%3E%3C/svg%3E">

	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

	<!-- TensorFlow.js and BodyPix - Free, no API key required -->
	<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>

	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		:root {
			--blue-primary: #1e3a8a;
			--blue-dark: #1e40af;
			--blue-light: #3b82f6;
			--blue-hover: #2563eb;
			--text-dark: #1e293b;
			--text-medium: #475569;
			--text-light: #64748b;
			--bg-white: #ffffff;
			--bg-light: #f1f5f9;
			--border-color: #e2e8f0;
			--shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);
			--shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
			--shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);
		}

		body {
			font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
			background: var(--bg-light);
			color: var(--text-dark);
			line-height: 1.6;
			min-height: 100vh;
			position: relative;
			overflow-x: hidden;
		}

		#page {
			position: relative;
			z-index: 1;
			min-height: 100vh;
			display: flex;
			flex-direction: column;
		}

		/* Header */
		.header {
			background: var(--blue-primary);
			padding: 4rem 0 3rem;
			box-shadow: var(--shadow-md);
		}

		.header-content {
			max-width: 1200px;
			margin: 0 auto;
			padding: 0 2rem;
			text-align: center;
		}

		.header h1 {
			font-size: clamp(2.5rem, 6vw, 3.5rem);
			font-weight: 700;
			color: white;
			margin-bottom: 0.75rem;
			letter-spacing: -0.02em;
		}

		.header p {
			font-size: clamp(1rem, 2vw, 1.125rem);
			color: rgba(255, 255, 255, 0.9);
			font-weight: 400;
			max-width: 600px;
			margin: 0 auto;
		}

		/* Main Container */
		.main-content {
			flex: 1;
			max-width: 1200px;
			margin: -3rem auto 0;
			padding: 0 2rem 4rem;
			position: relative;
			z-index: 2;
		}

		/* Alert Container */
		#alert-container {
			margin-bottom: 2rem;
		}

		.alert {
			padding: 1rem 1.25rem;
			border-radius: 8px;
			margin-bottom: 1rem;
			display: none;
			font-size: 0.95rem;
			box-shadow: var(--shadow-sm);
			border: 1px solid;
		}

		.alert.show {
			display: block;
		}

		.alert-success {
			background: #ecfdf5;
			color: #065f46;
			border-color: #10b981;
		}

		.alert-error {
			background: #fef2f2;
			color: #991b1b;
			border-color: #ef4444;
		}

		.alert-info {
			background: #eff6ff;
			color: #1e40af;
			border-color: var(--blue-light);
		}

		/* Upload Card */
		.upload-card {
			background: var(--bg-white);
			border-radius: 12px;
			padding: 0;
			box-shadow: var(--shadow-md);
			margin-bottom: 2rem;
			border: 1px solid var(--border-color);
		}

		.drop-zone {
			padding: 4rem 3rem;
			text-align: center;
			cursor: pointer;
			position: relative;
			background: var(--bg-white);
			transition: background-color 0.2s ease;
		}

		.drop-zone::before {
			content: '';
			position: absolute;
			top: 15px;
			left: 15px;
			right: 15px;
			bottom: 15px;
			border: 2px dashed var(--border-color);
			border-radius: 8px;
			transition: border-color 0.2s ease;
		}

		.drop-zone:hover {
			background: var(--bg-light);
		}

		.drop-zone:hover::before {
			border-color: var(--blue-light);
		}

		.drop-zone.drag-over {
			background: rgba(30, 58, 138, 0.05);
		}

		.drop-zone.drag-over::before {
			border-color: var(--blue-primary);
			border-style: solid;
		}

		.upload-icon {
			font-size: 4rem;
			color: var(--blue-primary);
			margin-bottom: 1.5rem;
			display: block;
		}

		.drop-zone h2 {
			font-size: 1.75rem;
			font-weight: 600;
			color: var(--text-dark);
			margin-bottom: 0.75rem;
		}

		.drop-zone p {
			color: var(--text-medium);
			font-size: 1.1rem;
			margin-bottom: 2.5rem;
			font-weight: 400;
		}

		.file-input {
			position: absolute;
			width: 0;
			height: 0;
			opacity: 0;
			pointer-events: none;
		}

		.btn-primary {
			background: var(--blue-primary);
			color: white;
			border: none;
			border-radius: 8px;
			padding: 0.875rem 2rem;
			font-size: 1rem;
			font-weight: 600;
			cursor: pointer;
			transition: background-color 0.2s ease;
			display: inline-flex;
			align-items: center;
			gap: 0.5rem;
		}

		.btn-primary:hover {
			background: var(--blue-hover);
		}

		.btn-primary:active {
			background: var(--blue-dark);
		}

		.btn-primary:disabled {
			opacity: 0.6;
			cursor: not-allowed;
		}

		/* Processing Card */
		.processing-card {
			background: var(--bg-white);
			border-radius: 12px;
			padding: 2rem;
			box-shadow: var(--shadow-md);
			display: none;
			margin-bottom: 2rem;
			border: 1px solid var(--border-color);
		}

		.processing-card.show {
			display: block;
		}

		.processing-header {
			display: flex;
			align-items: center;
			justify-content: space-between;
			margin-bottom: 1.5rem;
		}

		.processing-header h3 {
			font-size: 1.5rem;
			font-weight: 600;
			color: var(--text-dark);
			display: flex;
			align-items: center;
			gap: 0.75rem;
		}

		.processing-header h3 i {
			color: var(--blue-primary);
			font-size: 1.25rem;
		}

		.image-preview-container {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 2rem;
			margin-bottom: 2rem;
		}

		.preview-box {
			background: var(--bg-light);
			border-radius: 8px;
			padding: 1.5rem;
			border: 1px solid var(--border-color);
		}

		.preview-box h4 {
			font-size: 1rem;
			font-weight: 600;
			color: var(--text-dark);
			margin-bottom: 1rem;
			text-align: center;
		}

		.preview-image-wrapper {
			position: relative;
			width: 100%;
			background: 
				linear-gradient(45deg, #f0f0f0 25%, transparent 25%),
				linear-gradient(-45deg, #f0f0f0 25%, transparent 25%),
				linear-gradient(45deg, transparent 75%, #f0f0f0 75%),
				linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
			background-size: 20px 20px;
			background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
			border-radius: 8px;
			overflow: hidden;
			min-height: 200px;
			display: flex;
			align-items: center;
			justify-content: center;
		}

		.preview-image-wrapper img,
		.preview-image-wrapper canvas {
			max-width: 100%;
			max-height: 500px;
			display: block;
			border-radius: 8px;
		}

		.progress-container {
			margin-bottom: 2rem;
		}

		.progress-bar {
			width: 100%;
			height: 8px;
			background: var(--bg-light);
			border-radius: 4px;
			overflow: hidden;
			margin-bottom: 0.5rem;
		}

		.progress-fill {
			height: 100%;
			background: linear-gradient(90deg, var(--blue-primary), var(--blue-light));
			border-radius: 4px;
			transition: width 0.3s ease;
			width: 0%;
		}

		.progress-text {
			font-size: 0.9rem;
			color: var(--text-medium);
			text-align: center;
			font-weight: 500;
		}

		.actions-section {
			display: flex;
			gap: 1rem;
			justify-content: center;
			flex-wrap: wrap;
		}

		.btn-secondary {
			background: white;
			color: var(--blue-primary);
			border: 2px solid var(--blue-primary);
			border-radius: 8px;
			padding: 0.875rem 2rem;
			font-size: 1rem;
			font-weight: 600;
			cursor: pointer;
			transition: all 0.2s ease;
			display: inline-flex;
			align-items: center;
			gap: 0.5rem;
		}

		.btn-secondary:hover {
			background: var(--blue-primary);
			color: white;
		}

		.btn-download {
			background: var(--blue-primary);
			color: white;
			border: none;
			border-radius: 8px;
			padding: 0.875rem 2rem;
			font-size: 1rem;
			font-weight: 600;
			cursor: pointer;
			transition: background-color 0.2s ease;
			display: inline-flex;
			align-items: center;
			gap: 0.5rem;
		}

		.btn-download:hover {
			background: var(--blue-hover);
		}

		/* Spinner */
		.spinner {
			border: 3px solid rgba(30, 58, 138, 0.3);
			border-top: 3px solid var(--blue-primary);
			border-radius: 50%;
			width: 24px;
			height: 24px;
			animation: spin 0.8s linear infinite;
			display: inline-block;
		}

		@keyframes spin {
			0% { transform: rotate(0deg); }
			100% { transform: rotate(360deg); }
		}

		/* Footer */
		.footer {
			background: var(--bg-white);
			padding: 2.5rem 0;
			text-align: center;
			margin-top: 4rem;
			border-top: 1px solid #f1f5f9;
		}

		.footer-content {
			max-width: 1200px;
			margin: 0 auto;
			padding: 0 2rem;
		}

		.footer a {
			color: var(--blue-primary);
			text-decoration: none;
			font-weight: 500;
			font-size: 0.95rem;
			transition: color 0.2s ease;
			display: inline-flex;
			align-items: center;
			gap: 0.5rem;
		}

		.footer a:hover {
			color: var(--blue-hover);
		}

		/* Responsive */
		@media screen and (max-width: 768px) {
			.header {
				padding: 3rem 0 2rem;
			}

			.main-content {
				margin-top: -2rem;
				padding: 0 1.5rem 3rem;
			}

			.drop-zone {
				padding: 3rem 2rem;
			}

			.upload-icon {
				font-size: 3.5rem;
				margin-bottom: 1.25rem;
			}

			.drop-zone h2 {
				font-size: 1.5rem;
			}

			.drop-zone p {
				font-size: 1rem;
				margin-bottom: 2rem;
			}

			.image-preview-container {
				grid-template-columns: 1fr;
				gap: 1.5rem;
			}

			.actions-section {
				flex-direction: column;
			}

			.btn-primary,
			.btn-secondary,
			.btn-download {
				width: 100%;
				justify-content: center;
			}
		}

		@media screen and (max-width: 480px) {
			.header h1 {
				font-size: 2rem;
			}

			.drop-zone {
				padding: 2.5rem 1.5rem;
			}

			.processing-card {
				padding: 1.5rem;
			}
		}
	</style>
</head>

<body>
	<div id="page">
		<header class="header">
			<div class="header-content">
				<h1>Background Remover</h1>
				<p>Remove backgrounds from images with AI-powered precision</p>
			</div>
		</header>

		<div class="main-content">
			<!-- Alert messages -->
			<div id="alert-container"></div>

			<!-- Upload area -->
			<div class="upload-card">
				<div class="drop-zone" id="dropZone" onclick="document.getElementById('fileInput').click()">
					<i class="fas fa-image upload-icon"></i>
					<h2>Drop your image here</h2>
					<p>Support JPG, PNG, WEBP, and other common image formats</p>
					<button class="btn-primary" type="button" onclick="event.stopPropagation(); document.getElementById('fileInput').click();">
						<i class="fas fa-folder-open"></i> Choose Image
					</button>
					<input type="file" id="fileInput" class="file-input" accept="image/*">
				</div>
			</div>

			<!-- Processing area -->
			<div class="processing-card" id="processingCard">
				<div class="processing-header">
					<h3>
						<i class="fas fa-magic"></i> Processing Image
					</h3>
				</div>

				<div class="progress-container" id="progressContainer">
					<div class="progress-bar">
						<div class="progress-fill" id="progressFill"></div>
					</div>
					<div class="progress-text" id="progressText">Initializing...</div>
				</div>

				<div class="image-preview-container">
					<div class="preview-box">
						<h4>Original</h4>
						<div class="preview-image-wrapper">
							<img id="originalImage" alt="Original image">
						</div>
					</div>
					<div class="preview-box">
						<h4>Background Removed</h4>
						<div class="preview-image-wrapper">
							<canvas id="resultCanvas"></canvas>
						</div>
					</div>
				</div>

				<div class="actions-section">
					<button class="btn-secondary" id="newImageBtn" onclick="resetUpload()">
						<i class="fas fa-plus"></i> New Image
					</button>
					<button class="btn-download" id="downloadBtn" onclick="downloadImage()">
						<i class="fas fa-download"></i> Download
					</button>
				</div>
			</div>
		</div>

		<footer class="footer">
			<div class="footer-content">
				<a href="index.html">
					<i class="fas fa-arrow-left"></i> Back to Portfolio
				</a>
				<span style="margin: 0 1rem; color: var(--text-light);">|</span>
				<a href="mergePDF.html">
					<i class="fas fa-file-pdf"></i> MergePDF
				</a>
			</div>
		</footer>
	</div>

	<!-- jQuery -->
	<script src="js/jquery.min.js"></script>
	<!-- jQuery Easing -->
	<script src="js/jquery.easing.1.3.js"></script>
	<!-- Bootstrap -->
	<script src="js/bootstrap.min.js"></script>
	<!-- Waypoints -->
	<script src="js/jquery.waypoints.min.js"></script>
	<!-- Main -->
	<script src="js/main.js"></script>

	<script>
		let currentImage = null;
		let resultImageData = null;
		let bodyPixModel = null;

		// Load BodyPix using import() - more reliable
		async function loadBodyPix() {
			// Try using dynamic import with different CDNs
			const importUrls = [
				'https://cdn.skypack.dev/@tensorflow-models/body-pix@2.2.1',
				'https://esm.sh/@tensorflow-models/body-pix@2.2.1'
			];
			
			for (const url of importUrls) {
				try {
					const module = await import(url);
					// BodyPix might be exported as default or named export
					if (module.default) {
						window.bodyPix = module.default;
					} else if (module.bodyPix) {
						window.bodyPix = module.bodyPix;
					} else {
						window.bodyPix = module;
					}
					return; // Success!
				} catch (error) {
					console.warn(`Failed to import from ${url}:`, error);
					continue;
				}
			}
			
			// Fallback: try script tag with correct path
			return new Promise((resolve, reject) => {
				if (typeof bodyPix !== 'undefined') {
					resolve();
					return;
				}
				
				const script = document.createElement('script');
				// Try the actual npm package structure
				script.src = 'https://unpkg.com/@tensorflow-models/body-pix@2.2.1';
				script.type = 'module';
				script.onload = () => {
					setTimeout(() => {
						if (typeof bodyPix !== 'undefined') {
							resolve();
						} else {
							reject(new Error('BodyPix loaded but not available as global'));
						}
					}, 1000);
				};
				script.onerror = () => reject(new Error('Failed to load BodyPix script'));
				document.head.appendChild(script);
			});
		}

		// Initialize BodyPix model
		async function initializeModel() {
			try {
				showAlert('Loading AI model...', 'info');
				updateProgress(10, 'Loading TensorFlow.js...');
				
				// Wait for TensorFlow.js
				let retries = 0;
				while (typeof tf === 'undefined' && retries < 10) {
					await new Promise(resolve => setTimeout(resolve, 500));
					retries++;
				}
				
				if (typeof tf === 'undefined') {
					throw new Error('TensorFlow.js failed to load. Please check your internet connection.');
				}
				
				updateProgress(15, 'Loading BodyPix library...');
				
				// Load BodyPix dynamically
				try {
					await loadBodyPix();
				} catch (error) {
					console.error('Failed to load BodyPix:', error);
					throw new Error('BodyPix library failed to load. Please refresh the page.');
				}
				
				updateProgress(20, 'Loading BodyPix model...');
				
				// Try to load MobileNet first (faster, lighter)
				try {
					bodyPixModel = await bodyPix.load({
						architecture: 'MobileNetV1',
						outputStride: 16,
						multiplier: 0.75,
						quantBytes: 2
					});
					updateProgress(30, 'Model loaded successfully');
					showAlert('Ready! Upload an image to remove its background.', 'success');
					return true;
				} catch (error) {
					console.warn('MobileNet failed, trying ResNet50...', error);
					updateProgress(25, 'Trying alternative model...');
					// Fallback to ResNet50 if MobileNet fails
					bodyPixModel = await bodyPix.load({
						architecture: 'ResNet50',
						outputStride: 16,
						quantBytes: 2,
						multiplier: 0.75
					});
					updateProgress(30, 'Model loaded successfully');
					showAlert('Ready! Upload an image to remove its background.', 'success');
					return true;
				}
			} catch (error) {
				console.error('Error loading model:', error);
				showAlert('Failed to load AI model: ' + error.message + '. Please refresh the page.', 'error');
				return false;
			}
		}

		// Show alert
		function showAlert(message, type = 'info') {
			const alertContainer = document.getElementById('alert-container');
			const alert = document.createElement('div');
			alert.className = `alert alert-${type} show`;
			alert.textContent = message;
			alertContainer.innerHTML = '';
			alertContainer.appendChild(alert);
			
			if (type === 'success' || type === 'info') {
				setTimeout(() => {
					alert.classList.remove('show');
				}, 5000);
			}
		}

		// Update progress
		function updateProgress(percent, text) {
			document.getElementById('progressFill').style.width = percent + '%';
			document.getElementById('progressText').textContent = text;
		}

		// Handle file input
		document.getElementById('fileInput').addEventListener('change', async (e) => {
			const file = e.target.files[0];
			if (file) {
				await processImage(file);
			}
		});

		// Drag and drop handlers
		const dropZone = document.getElementById('dropZone');
		
		dropZone.addEventListener('dragover', (e) => {
			e.preventDefault();
			dropZone.classList.add('drag-over');
		});

		dropZone.addEventListener('dragleave', () => {
			dropZone.classList.remove('drag-over');
		});

		dropZone.addEventListener('drop', async (e) => {
			e.preventDefault();
			dropZone.classList.remove('drag-over');
			
			const file = e.dataTransfer.files[0];
			if (file && file.type.startsWith('image/')) {
				await processImage(file);
			} else {
				showAlert('Please drop a valid image file.', 'error');
			}
		});

		// Process image using BodyPix
		async function processImage(file) {
			if (!bodyPixModel) {
				showAlert('AI model is still loading. Please wait...', 'error');
				return;
			}

			try {
				// Show processing card
				document.getElementById('processingCard').classList.add('show');
				updateProgress(20, 'Loading image...');

				// Load image
				const imageUrl = URL.createObjectURL(file);
				const img = new Image();
				
				await new Promise((resolve, reject) => {
					img.onload = resolve;
					img.onerror = reject;
					img.src = imageUrl;
				});

				currentImage = img;
				document.getElementById('originalImage').src = imageUrl;
				updateProgress(40, 'Detecting person...');

				// Create canvas for processing
				const canvas = document.getElementById('resultCanvas');
				const ctx = canvas.getContext('2d');
				canvas.width = img.width;
				canvas.height = img.height;
				
				// Draw original image
				ctx.drawImage(img, 0, 0);
				
				// Process with BodyPix
				updateProgress(60, 'Segmenting image...');
				const segmentation = await bodyPixModel.segmentPerson(img, {
					flipHorizontal: false,
					internalResolution: 'high',
					segmentationThreshold: 0.7
				});
				
				updateProgress(80, 'Removing background...');
				
				// Get image data
				const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
				const data = imageData.data;
				const mask = segmentation.data;
				
				// Resize mask if needed (BodyPix might return smaller mask)
				let finalMask = mask;
				if (mask.length !== canvas.width * canvas.height) {
					// Need to resize mask
					const maskCanvas = document.createElement('canvas');
					maskCanvas.width = segmentation.width;
					maskCanvas.height = segmentation.height;
					const maskCtx = maskCanvas.getContext('2d');
					const maskImageData = maskCtx.createImageData(segmentation.width, segmentation.height);
					for (let i = 0; i < mask.length; i++) {
						const val = mask[i] ? 255 : 0;
						maskImageData.data[i * 4] = val;
						maskImageData.data[i * 4 + 1] = val;
						maskImageData.data[i * 4 + 2] = val;
						maskImageData.data[i * 4 + 3] = 255;
					}
					maskCtx.putImageData(maskImageData, 0, 0);
					
					// Draw resized mask to main canvas temporarily to get correct size
					const tempCanvas = document.createElement('canvas');
					tempCanvas.width = canvas.width;
					tempCanvas.height = canvas.height;
					const tempCtx = tempCanvas.getContext('2d');
					tempCtx.drawImage(maskCanvas, 0, 0, canvas.width, canvas.height);
					const resizedMaskData = tempCtx.getImageData(0, 0, canvas.width, canvas.height).data;
					
					// Apply mask
					for (let i = 0; i < data.length; i += 4) {
						const maskIdx = i;
						const maskValue = resizedMaskData[maskIdx]; // Red channel
						
						// If mask is dark (background), make transparent
						if (maskValue < 128) {
							data[i + 3] = 0; // Set alpha to 0 (transparent)
						}
					}
				} else {
					// Apply mask directly
					for (let i = 0; i < data.length; i += 4) {
						const maskIdx = i / 4;
						if (!mask[maskIdx]) {
							data[i + 3] = 0; // Set alpha to 0 (transparent)
						}
					}
				}
				
				ctx.putImageData(imageData, 0, 0);
				
				// Store result for download
				resultImageData = canvas.toDataURL('image/png');
				
				updateProgress(100, 'Complete!');
				showAlert('Background removed successfully!', 'success');
				
				// Clean up
				URL.revokeObjectURL(imageUrl);

			} catch (error) {
				console.error('Error processing image:', error);
				showAlert('Failed to process image: ' + error.message, 'error');
				updateProgress(0, 'Error occurred');
			}
		}
		
		// Advanced multi-stage background removal algorithm (kept as fallback, not currently used)
		async function advancedBackgroundRemoval(img, canvas, ctx) {
			updateProgress(45, 'Stage 1: Analyzing image structure...');
			
			// Draw original image
			ctx.drawImage(img, 0, 0);
			
			// Get image data
			const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
			const data = imageData.data;
			const width = canvas.width;
			const height = canvas.height;
			
			// Stage 1: Sample background from edges and corners
			updateProgress(50, 'Stage 2: Identifying background regions...');
			const bgMask = identifyBackgroundRegions(data, width, height);
			
			// Stage 2: Flood fill from edges to catch all background
			updateProgress(60, 'Stage 3: Flood filling background...');
			floodFillBackground(bgMask, data, width, height);
			
			// Stage 3: Refine using edge detection
			updateProgress(70, 'Stage 4: Refining edges...');
			refineWithEdgeDetection(bgMask, data, width, height);
			
			// Stage 4: Apply mask to image
			updateProgress(80, 'Stage 5: Applying mask...');
			for (let i = 0; i < data.length; i += 4) {
				const idx = i / 4;
				if (bgMask[idx]) {
					data[i + 3] = 0; // Make background transparent
				}
			}
			
			// Stage 5: Smooth edges with alpha matting
			updateProgress(85, 'Stage 6: Creating smooth edges...');
			applyAlphaMatting(data, bgMask, width, height);
			
			// Stage 6: Remove artifacts
			updateProgress(88, 'Stage 7: Removing artifacts...');
			removeArtifacts(data, width, height);
			
			// Put modified image data back
			ctx.putImageData(imageData, 0, 0);
		}
		
		// Identify background regions using multiple heuristics
		function identifyBackgroundRegions(data, width, height) {
			const bgMask = new Uint8Array(width * height); // 1 = background, 0 = foreground
			const sampleSize = Math.min(width, height) * 0.12;
			
			// Sample background colors from corners and edges
			const bgSamples = [];
			const edgeSamples = [];
			
			// Sample corners
			for (let y = 0; y < sampleSize; y++) {
				for (let x = 0; x < sampleSize; x++) {
					const corners = [
						y * width + x,
						y * width + (width - 1 - x),
						(height - 1 - y) * width + x,
						(height - 1 - y) * width + (width - 1 - x)
					];
					
					for (const idx of corners) {
						const pixelIndex = idx * 4;
						bgSamples.push({
							r: data[pixelIndex],
							g: data[pixelIndex + 1],
							b: data[pixelIndex + 2],
							idx: idx
						});
					}
				}
			}
			
			// Sample edges (top, bottom, left, right)
			const edgeThickness = Math.min(width, height) * 0.05;
			for (let i = 0; i < edgeThickness; i++) {
				// Top edge
				for (let x = 0; x < width; x++) {
					const idx = i * width + x;
					const pixelIndex = idx * 4;
					edgeSamples.push({
						r: data[pixelIndex],
						g: data[pixelIndex + 1],
						b: data[pixelIndex + 2],
						idx: idx
					});
				}
				// Bottom edge
				for (let x = 0; x < width; x++) {
					const idx = (height - 1 - i) * width + x;
					const pixelIndex = idx * 4;
					edgeSamples.push({
						r: data[pixelIndex],
						g: data[pixelIndex + 1],
						b: data[pixelIndex + 2],
						idx: idx
					});
				}
				// Left edge
				for (let y = 0; y < height; y++) {
					const idx = y * width + i;
					const pixelIndex = idx * 4;
					edgeSamples.push({
						r: data[pixelIndex],
						g: data[pixelIndex + 1],
						b: data[pixelIndex + 2],
						idx: idx
					});
				}
				// Right edge
				for (let y = 0; y < height; y++) {
					const idx = y * width + (width - 1 - i);
					const pixelIndex = idx * 4;
					edgeSamples.push({
						r: data[pixelIndex],
						g: data[pixelIndex + 1],
						b: data[pixelIndex + 2],
						idx: idx
					});
				}
			}
			
			// Cluster background colors using K-means (simplified)
			const bgClusters = clusterColors([...bgSamples, ...edgeSamples], 3);
			
			// Calculate center region (likely foreground)
			const centerX = width / 2;
			const centerY = height / 2;
			const centerRadius = Math.min(width, height) * 0.35;
			
			// Classify each pixel
			for (let y = 0; y < height; y++) {
				for (let x = 0; x < width; x++) {
					const idx = y * width + x;
					const pixelIndex = idx * 4;
					const r = data[pixelIndex];
					const g = data[pixelIndex + 1];
					const b = data[pixelIndex + 2];
					
					// Distance from center
					const distFromCenter = Math.sqrt(
						Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2)
					);
					
					// Check if pixel matches background clusters
					let minDist = Infinity;
					for (const cluster of bgClusters) {
						const dist = Math.sqrt(
							Math.pow(r - cluster.r, 2) +
							Math.pow(g - cluster.g, 2) +
							Math.pow(b - cluster.b, 2)
						);
						minDist = Math.min(minDist, dist);
					}
					
					// Classify as background if:
					// 1. Far from center AND similar to background colors
					// 2. Very similar to background colors (even if near center)
					const isBackground = (distFromCenter > centerRadius && minDist < 40) || 
					                     (minDist < 25) ||
					                     (distFromCenter > centerRadius * 1.5);
					
					bgMask[idx] = isBackground ? 1 : 0;
				}
			}
			
			return bgMask;
		}
		
		// Simple K-means clustering for background colors
		function clusterColors(samples, k) {
			if (samples.length === 0) return [];
			
			// Initialize centroids randomly
			let centroids = [];
			for (let i = 0; i < k && i < samples.length; i++) {
				const sample = samples[Math.floor(Math.random() * samples.length)];
				centroids.push({ r: sample.r, g: sample.g, b: sample.b });
			}
			
			// Iterate a few times
			for (let iter = 0; iter < 5; iter++) {
				// Assign samples to nearest centroid
				const clusters = centroids.map(() => []);
				for (const sample of samples) {
					let minDist = Infinity;
					let nearestIdx = 0;
					for (let i = 0; i < centroids.length; i++) {
						const dist = Math.sqrt(
							Math.pow(sample.r - centroids[i].r, 2) +
							Math.pow(sample.g - centroids[i].g, 2) +
							Math.pow(sample.b - centroids[i].b, 2)
						);
						if (dist < minDist) {
							minDist = dist;
							nearestIdx = i;
						}
					}
					clusters[nearestIdx].push(sample);
				}
				
				// Update centroids
				centroids = clusters.map(cluster => {
					if (cluster.length === 0) return { r: 0, g: 0, b: 0 };
					const sum = cluster.reduce((acc, s) => ({
						r: acc.r + s.r,
						g: acc.g + s.g,
						b: acc.b + s.b
					}), { r: 0, g: 0, b: 0 });
					return {
						r: sum.r / cluster.length,
						g: sum.g / cluster.length,
						b: sum.b / cluster.length
					};
				});
			}
			
			return centroids;
		}
		
		// Flood fill from edges to catch all background
		function floodFillBackground(bgMask, data, width, height) {
			const visited = new Uint8Array(width * height);
			const queue = [];
			
			// Start flood fill from edge pixels marked as background
			for (let y = 0; y < height; y++) {
				for (let x = 0; x < width; x++) {
					const idx = y * width + x;
					if ((x < 2 || x >= width - 2 || y < 2 || y >= height - 2) && bgMask[idx]) {
						queue.push({ x, y });
						visited[idx] = 1;
					}
				}
			}
			
			// Flood fill
			while (queue.length > 0) {
				const { x, y } = queue.shift();
				const idx = y * width + x;
				const pixelIndex = idx * 4;
				const r = data[pixelIndex];
				const g = data[pixelIndex + 1];
				const b = data[pixelIndex + 2];
				
				// Check neighbors
				const neighbors = [
					{ x: x - 1, y },
					{ x: x + 1, y },
					{ x, y: y - 1 },
					{ x, y: y + 1 }
				];
				
				for (const neighbor of neighbors) {
					if (neighbor.x < 0 || neighbor.x >= width || neighbor.y < 0 || neighbor.y >= height) continue;
					
					const nIdx = neighbor.y * width + neighbor.x;
					if (visited[nIdx]) continue;
					
					const nPixelIndex = nIdx * 4;
					const nr = data[nPixelIndex];
					const ng = data[nPixelIndex + 1];
					const nb = data[nPixelIndex + 2];
					
					// Color similarity
					const colorDist = Math.sqrt(
						Math.pow(r - nr, 2) + Math.pow(g - ng, 2) + Math.pow(b - nb, 2)
					);
					
					// If similar color, mark as background
					if (colorDist < 35) {
						bgMask[nIdx] = 1;
						visited[nIdx] = 1;
						queue.push(neighbor);
					}
				}
			}
		}
		
		// Refine mask using edge detection
		function refineWithEdgeDetection(bgMask, data, width, height) {
			// Convert to grayscale
			const grayscale = new Uint8Array(width * height);
			for (let i = 0; i < data.length; i += 4) {
				grayscale[i / 4] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
			}
			
			// Detect edges
			const edges = new Uint8Array(width * height);
			for (let y = 1; y < height - 1; y++) {
				for (let x = 1; x < width - 1; x++) {
					const idx = y * width + x;
					const gx = -grayscale[(y - 1) * width + (x - 1)] + grayscale[(y - 1) * width + (x + 1)]
						- 2 * grayscale[y * width + (x - 1)] + 2 * grayscale[y * width + (x + 1)]
						- grayscale[(y + 1) * width + (x - 1)] + grayscale[(y + 1) * width + (x + 1)];
					const gy = -grayscale[(y - 1) * width + (x - 1)] - 2 * grayscale[(y - 1) * width + x]
						- grayscale[(y - 1) * width + (x + 1)] + grayscale[(y + 1) * width + (x - 1)]
						+ 2 * grayscale[(y + 1) * width + x] + grayscale[(y + 1) * width + (x + 1)];
					edges[idx] = Math.min(255, Math.sqrt(gx * gx + gy * gy));
				}
			}
			
			// Refine mask: pixels near strong edges are likely foreground
			for (let y = 2; y < height - 2; y++) {
				for (let x = 2; x < width - 2; x++) {
					const idx = y * width + x;
					
					// Check if there's a strong edge nearby
					let maxEdge = 0;
					for (let dy = -2; dy <= 2; dy++) {
						for (let dx = -2; dx <= 2; dx++) {
							const nIdx = (y + dy) * width + (x + dx);
							maxEdge = Math.max(maxEdge, edges[nIdx]);
						}
					}
					
					// If strong edge and currently marked as background, might be foreground
					if (maxEdge > 50 && bgMask[idx]) {
						// Check if neighbors are mostly foreground
						let fgNeighbors = 0;
						for (let dy = -1; dy <= 1; dy++) {
							for (let dx = -1; dx <= 1; dx++) {
								if (dx === 0 && dy === 0) continue;
								const nIdx = (y + dy) * width + (x + dx);
								if (!bgMask[nIdx]) fgNeighbors++;
							}
						}
						
						if (fgNeighbors > 4) {
							bgMask[idx] = 0; // Mark as foreground
						}
					}
				}
			}
		}
		
		// Apply alpha matting for smooth edges
		function applyAlphaMatting(data, bgMask, width, height) {
			const alphaMap = new Float32Array(width * height);
			
			// Create distance transform
			for (let y = 0; y < height; y++) {
				for (let x = 0; x < width; x++) {
					const idx = y * width + x;
					if (bgMask[idx]) {
						alphaMap[idx] = 0.0;
					} else {
						// Find distance to nearest background pixel
						let minDist = Infinity;
						for (let dy = -5; dy <= 5; dy++) {
							for (let dx = -5; dx <= 5; dx++) {
								const ny = y + dy;
								const nx = x + dx;
								if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
									const nIdx = ny * width + nx;
									if (bgMask[nIdx]) {
										const dist = Math.sqrt(dx * dx + dy * dy);
										minDist = Math.min(minDist, dist);
									}
								}
							}
						}
						
						// Create smooth alpha based on distance
						if (minDist < Infinity) {
							alphaMap[idx] = Math.min(1.0, Math.max(0.0, 1.0 - minDist / 3.0));
						} else {
							alphaMap[idx] = 1.0;
						}
					}
				}
			}
			
			// Apply alpha
			for (let i = 0; i < data.length; i += 4) {
				const idx = i / 4;
				const alpha = alphaMap[idx];
				data[i + 3] = Math.round(alpha * 255);
			}
		}
		
		// Remove artifacts (small isolated background regions)
		function removeArtifacts(data, width, height) {
			const alpha = new Uint8Array(width * height);
			for (let i = 0; i < data.length; i += 4) {
				alpha[i / 4] = data[i + 3];
			}
			
			// Remove small isolated transparent regions (likely artifacts)
			const visited = new Uint8Array(width * height);
			for (let y = 1; y < height - 1; y++) {
				for (let x = 1; x < width - 1; x++) {
					const idx = y * width + x;
					if (visited[idx] || alpha[idx] > 10) continue;
					
					// Flood fill to find connected transparent region
					const region = [];
					const queue = [{ x, y }];
					visited[idx] = 1;
					
					while (queue.length > 0) {
						const { x: cx, y: cy } = queue.shift();
						const cIdx = cy * width + cx;
						region.push(cIdx);
						
						const neighbors = [
							{ x: cx - 1, y: cy },
							{ x: cx + 1, y: cy },
							{ x: cx, y: cy - 1 },
							{ x: cx, y: cy + 1 }
						];
						
						for (const neighbor of neighbors) {
							if (neighbor.x < 0 || neighbor.x >= width || neighbor.y < 0 || neighbor.y >= height) continue;
							const nIdx = neighbor.y * width + neighbor.x;
							if (visited[nIdx] || alpha[nIdx] > 10) continue;
							visited[nIdx] = 1;
							queue.push(neighbor);
						}
					}
					
					// If region is small and surrounded by opaque pixels, fill it
					if (region.length < 100) {
						for (const rIdx of region) {
							data[rIdx * 4 + 3] = 255; // Make opaque
						}
					}
				}
			}
		}
		
		// Apply morphological operations to clean up mask
		function applyMorphologicalOperations(data, width, height) {
			const alphaChannel = new Uint8Array(width * height);
			for (let i = 0; i < data.length; i += 4) {
				alphaChannel[i / 4] = data[i + 3];
			}
			
			// Erosion followed by dilation (opening)
			const kernelSize = 3;
			const halfKernel = Math.floor(kernelSize / 2);
			
			// Erosion
			const eroded = new Uint8Array(width * height);
			for (let y = halfKernel; y < height - halfKernel; y++) {
				for (let x = halfKernel; x < width - halfKernel; x++) {
					const idx = y * width + x;
					let minAlpha = 255;
					for (let ky = -halfKernel; ky <= halfKernel; ky++) {
						for (let kx = -halfKernel; kx <= halfKernel; kx++) {
							const neighborIdx = (y + ky) * width + (x + kx);
							minAlpha = Math.min(minAlpha, alphaChannel[neighborIdx]);
						}
					}
					eroded[idx] = minAlpha;
				}
			}
			
			// Dilation
			const dilated = new Uint8Array(width * height);
			for (let y = halfKernel; y < height - halfKernel; y++) {
				for (let x = halfKernel; x < width - halfKernel; x++) {
					const idx = y * width + x;
					let maxAlpha = 0;
					for (let ky = -halfKernel; ky <= halfKernel; ky++) {
						for (let kx = -halfKernel; kx <= halfKernel; kx++) {
							const neighborIdx = (y + ky) * width + (x + kx);
							maxAlpha = Math.max(maxAlpha, eroded[neighborIdx]);
						}
					}
					dilated[idx] = maxAlpha;
				}
			}
			
			// Apply to image data
			for (let i = 0; i < data.length; i += 4) {
				data[i + 3] = dilated[i / 4];
			}
		}

		// Download image
		function downloadImage() {
			if (!resultImageData) {
				showAlert('No processed image available.', 'error');
				return;
			}

			const link = document.createElement('a');
			link.download = 'background-removed.png';
			link.href = resultImageData;
			link.click();
		}

		// Reset upload
		function resetUpload() {
			document.getElementById('processingCard').classList.remove('show');
			document.getElementById('fileInput').value = '';
			currentImage = null;
			resultImageData = null;
			document.getElementById('originalImage').src = '';
			const canvas = document.getElementById('resultCanvas');
			const ctx = canvas.getContext('2d');
			ctx.clearRect(0, 0, canvas.width, canvas.height);
		}

		// Initialize on page load - wait a bit for scripts to load
		window.addEventListener('load', () => {
			// Wait a moment for all scripts to load
			setTimeout(() => {
				initializeModel();
			}, 500);
		});
	</script>
</body>

</html>

